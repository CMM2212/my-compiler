package compiler.tac;

import compiler.parser.ast.ASTVisitor;
import compiler.parser.ast.nodes.*;
import compiler.parser.ast.nodes.declarations.*;
import compiler.parser.ast.nodes.expressions.*;
import compiler.parser.ast.nodes.expressions.operations.*;
import compiler.parser.ast.nodes.statements.*;
import compiler.parser.ast.nodes.structures.ProgramNode;
import compiler.parser.ast.nodes.terminals.*;
import compiler.typechecker.TypeChecker;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * The intermediate code generator is responsible for generating three address code (TAC) from the
 * type checked program AST.
 *
 * The TAC is generated by linearizing the AST. This process requires reducing all statements to
 * only using at most 3 values per instruction. To do this, instructions with more than 3 must
 * be separated into multiple instructions. For example, a = 5 + 5 * 5 would be reduced to
 * t1 = 5 * 5; a = 5 + t1;
 *
 * To handle control flow, labels are generated which then can be used in conjunction with goto
 * statements and if statements to handle branching and looping.
 *
 * Arrays are also handled by calculating the offset of the combined dimensions and the size of
 * the data type in order to access the correct memory location as an identifier and an offset.
 *
 * Unlike the AST, the intermediate code is a linear list of statements which will be executed
 * in order.
 */
public class IntermediateCodeGenerator implements ASTVisitor {
    public ProgramNode program = null;
    // List of all TAC statements that will make up the intermediate code.
    public List<StatementNode> currentStatements;
    // A stack of end labels so the break statement knows where to go in its current loop.
    public Stack<LabelNode> loopEndLabels = new Stack<>();

    /**
     * Creates an intermediate code generator using the type checked program AST from the
     * type checker, and immediately generates the intermediate code. The intermediate code
     * will be stored as a list of statements in the currentStatements field.
     *
     * @param typeChecker The type checker which has type checked the parsed AST.
     */
    public IntermediateCodeGenerator(TypeChecker typeChecker) {
        typeChecker.program.accept(this);
        program = typeChecker.program;
    }

    /**
     * Visits the program node and initializes the current statements list.
     *
     * The currentStatements list will store all the statements involved in the program.
     *
     * @param node The program node to visit.
     */
    @Override
    public void visit(ProgramNode node) {
        currentStatements = new ArrayList<>();
        node.block.accept(this);
    }

    /**
     * Visit a block node and visit all the statements within the block.
     *
     * Declarations are ignored because they are for the type checker and not necessary for the intermediate code.
     *
     * @param node The block node to visit.
     */
    @Override
    public void visit(BlockNode node) {
        for (StatementNode statement : node.statements)
            statement.accept(this);
    }

    /**
     * Reduce the assignment node's left and right side and emit an assignment statement.
     *
     * The left side is reduced to a LocNode which is a single identifier and optional array access.
     * If there is an array access, then the right side is reduced to a single value, a temp variable.
     *
     * Example of possible returns: a[542] = 5, a = 5 + 5, a[100] = t1
     *
     * @param node The assignment node to visit.
     */
    @Override
    public void visit(AssignmentNode node) {
        node.left = reduceLocNode(node.left, false);
        node.expression = reduceExpression(node.expression, node.left.isArray());
        emitAssignment(node.left, node.expression);
    }

    /**
     * Visit an IfNode and reduce the expression and statement(s).
     *
     * This will emit labels, goto, and ifFalse statements to handle flow control.
     *
     * @param node The IfNode to visit.
     */
    @Override
    public void visit(IfNode node) {
        node.expression = reduceExpression(node.expression, false);

        LabelNode falseLabel = LabelNode.newLabel();
        // End label only necessary if there is an else statement.
        LabelNode endLabel = (node.elseStatement != null) ? LabelNode.newLabel() : null;

        emitIfFalse(node.expression, falseLabel);

        node.thenStatement.accept(this);

        if (node.elseStatement != null)
            emitGoto(endLabel);

        emitLabel(falseLabel);

        if (node.elseStatement != null) {
            node.elseStatement.accept(this);
            emitLabel(endLabel);
        }
    }

    /**
     * Visit a WhileNode and reduce the expression and body.
     *
     * This will emit labels, goto, and ifFalse statements to handle flow control. If
     * the statement is a true literal, it will skip the conditional part and just have
     * the loop structure.
     *
     * @param node The WhileNode to visit.
     */
    @Override
    public void visit(WhileNode node) {
        LabelNode startLabel = LabelNode.newLabel();
        LabelNode endLabel = LabelNode.newLabel();
        emitLabel(startLabel);

        // If it is a true literal, we don't need a false check.
        if (!(node.expression instanceof TrueNode)) {
            node.expression = reduceExpression(node.expression, false);
            emitIfFalse(node.expression, endLabel);
        }

        loopEndLabels.push(endLabel);
        node.body.accept(this);
        loopEndLabels.pop();

        emitGoto(startLabel);
        emitLabel(endLabel);
    }

    /**
     * Visit a DoWhileNode and reduce the expression and body.
     *
     * This will emit labels, goto, and ifTrue statements to handle flow control.
     *
     * @param node The DoWhileNode to visit.
     */
    @Override
    public void visit(DoWhileNode node) {
        LabelNode startLabel = LabelNode.newLabel();
        LabelNode endLabel = LabelNode.newLabel();
        emitLabel(startLabel);

        loopEndLabels.push(endLabel);
        node.body.accept(this);
        loopEndLabels.pop();

        node.expression = reduceExpression(node.expression, false);

        emitIfTrue(node.expression, startLabel);
    }


    /**
     * Visit a BreakNode and emit a goto statement to the end of the loop.
     *
     * @param node The BreakNode to visit.
     */
    @Override
    public void visit(BreakNode node) {
        emitGoto(loopEndLabels.peek());
    }

    /**
     * Reduce the expression of the node to a single value if needSingleResult is true, otherwise
     * reduce to at most two values.
     *
     * This will choose the correct method to do the reduction based on the type of node. If
     * It's BinaryExpression, Unary, Loc, or Parenthesis, it is already reduced and will return itself.
     *
     * Temporary variables will be assigned along the way to store intermediate results.
     *
     * Example: 5 + 5 * 5 could be reduced to t1 = 5 * 5; t2 = 5 + t1 through this.
     *
     * @param node             The expression node to reduce.
     * @param needSingleResult If true, reduce to a single value, otherwise reduce to at most two values.
     * @return The final reduced expression node.
     */
    public ExpressionNode reduceExpression(ExpressionNode node, Boolean needSingleResult) {
        if (node instanceof BinaryExpressionNode)
            return reduceBinaryExpression((BinaryExpressionNode) node, needSingleResult);
        if (node instanceof UnaryNode)
            return reduceUnaryExpression((UnaryNode) node, needSingleResult);
        if (node instanceof LocNode)
            return reduceLocNode((LocNode) node, needSingleResult);
        if (node instanceof ParenthesisNode) // Just ignore the parenthesis and reduce the expression inside.
            return reduceExpression(((ParenthesisNode) node).expression, needSingleResult);
        return node;
    }

    /**
     * Reduces a binary expression node by reducing the left and right expressions.
     *
     * If the needSingleResult is true, it will store the binary expression as a temporary variable
     * and return that temporary variable.
     *
     * @param node             The binary expression node to reduce.
     * @param needSingleResult If true, reduce to a temp variable, otherwise just reduce the left/right.
     * @return The final reduced binary expression node, or a temp variable pointing to its result.
     */
    public ExpressionNode reduceBinaryExpression(BinaryExpressionNode node, Boolean needSingleResult) {
        // The left and right will always need to be reduced to a single value.
        ExpressionNode left = reduceExpression(node.left, true);
        ExpressionNode right = reduceExpression(node.right, true);

        // If it needs to be a single result, store the binary expression as a temporary variable.
        BinaryExpressionNode result = new BinaryExpressionNode(left, right, node.operator);
        if (needSingleResult) {
            TempNode temp = TempNode.newTemp();
            emitAssignment(temp, result);
            return temp;
        }
        return result;
    }

    /**
     * Reduces the inner expression of a unary node.
     *
     * @param node             The unary node to reduce.
     * @param needSingleResult If true, the inner expression will be stored as a temporary variable,
     *                         otherwise it will just be reduced to at most two values.
     * @return The final reduced unary node.
     */
    public ExpressionNode reduceUnaryExpression(UnaryNode node, Boolean needSingleResult) {
        node.expression = reduceExpression(node.expression, needSingleResult);
        return node;
    }

    /**
     * Reduce a loc node by reducing array accessors to a single offset value.
     *
     * If needSingleResult is true, store the array access as a temporary variable.
     *
     * The goal of this is to calculate the total memory access offset for the array by
     * reducing the dimension expressions, summing the strides, and then multiplying it
     * by the size of the type. It returns a new loc node with the original identifier
     * and a one dimensional memory access offset.
     *
     * @param node             The loc node to reduce.
     * @param needSingleResult If true, store the array access as a temporary variable.
     *                         Otherwise, just reduce the array accessors to a single offset value.
     * @return The final reduced loc node.
     */
    public LocNode reduceLocNode(LocNode node, Boolean needSingleResult) {
        // If it's not an array, just return the loc node which is a single identifier.
        if (!node.isArray())
            return node;

        // For each dimensional accessor, reduce the expression and store as a list.
        // (e.g. a[1][1+2][3] -> [1, t1, 3])
        List<ExpressionNode> reducedDimensions = reduceDimensions(node);

        // Go through each dimension and calculate the accumulated offset.
        ExpressionNode totalOffset = null;
        for (int i = 0; i < reducedDimensions.size(); i++) {
            // Calculate the offset of the dimension based on the stride.
            ExpressionNode additionalOffset = calculateOffset(node, i, reducedDimensions);
            // Add this additional offset to the total offset.
            totalOffset = addAdditionalOffset(totalOffset, additionalOffset);
        }

        // Create a final loc node that uses the initial identifier and the final offset value to access it.
        LocNode finalLoc = createFinalLoc(node, totalOffset);

        // If it requires a single result, store the array access as a temporary variable.
        // (e.g. a[100] = a[10] -> t1 = a[10]; a[100] = t1)
        if (needSingleResult) {
            TempNode temp = TempNode.newTemp();
            emitAssignment(temp, finalLoc);
            return temp;
        } else {
            return finalLoc;
        }
    }

    /**
     * Creates the final LocNode for the reduced loc node by multiplying the calculated dimensional offset
     * by the size of the type.
     *
     * For example, if the total offset is 10 and the type is int, int is 4 bytes wide, so the final offset
     * is 4 * 10 = 40.
     *
     * @param node        The original loc node.
     * @param totalOffset The total offset value of the array access.
     * @return The final loc node with the calculated offset stored as its array accessor.
     */
    private LocNode createFinalLoc(LocNode node, ExpressionNode totalOffset) {
        TempNode finalOffset = TempNode.newTemp();
        // Multiply the total offset by the width (bytes) of the type to get the final offset value.
        emitAssignment(finalOffset, new BinaryExpressionNode(totalOffset, node.getWidthNumNode(), "*"));
        // Create a new loc node with the final offset, n[finalOffset].
        return new LocNode(node.id, new ArrayLocNode(null, finalOffset));
    }

    /**
     * Adds the additional offset to the total offset.
     *
     * @param totalOffset      The total offset value currently.
     * @param additionalOffset The additional offset to add to the total offset.
     * @return The new total offset value.
     */
    private ExpressionNode addAdditionalOffset(ExpressionNode totalOffset, ExpressionNode additionalOffset) {
        // If it's the first offset, initialize the total offset with this additional offset.
        if (totalOffset == null) {
            totalOffset = additionalOffset;
            // Otherwise, add the additional offset to the total offset.
        } else {
            TempNode temp = TempNode.newTemp();
            emitAssignment(temp, new BinaryExpressionNode(totalOffset, additionalOffset, "+"));
            totalOffset = temp;
        }
        return totalOffset;
    }

    /**
     * Calculate the offset of a given dimension by multiplying the dimension expression by
     * the stride of the dimension.
     *
     * @param node              The loc node to calculate the offset for.
     * @param i                 The index of the dimension to calculate the offset for.
     * @param reducedDimensions The reduced dimension expressions.
     * @return The additional offset for the given dimension.
     */
    private ExpressionNode calculateOffset(LocNode node, int i, List<ExpressionNode> reducedDimensions) {
        // Get the dimension expression.
        // (e.g. a[10][20] would return 10 for i = 0 and 20 for i = 1)
        ExpressionNode dimension = reducedDimensions.get(i);
        ExpressionNode additionalOffset;
        // If it's the last dimension, you don't need to calculate the stride because it's 1.
        if (i == reducedDimensions.size() - 1) {
            additionalOffset = dimension;
            // Otherwise, calculate stride and multiply it by the dimension expression.
        } else {
            TempNode temp = TempNode.newTemp();
            NumNode stride = new NumNode(calculateStride(node.id.getType(), i));
            emitAssignment(temp, new BinaryExpressionNode(dimension, stride, "*"));
            additionalOffset = temp;
        }
        return additionalOffset;
    }

    /**
     * Calculate the stride of a given dimension.
     *
     * This calculates the stride by multiplying the sizes of each of the dimensions after
     * the given dimension.
     *
     * For example, if you declare an int array as int[3][5][7], there are 3 dimensions 0, 1, 2.
     * The stride of 0 would be 5 * 7 = 35
     * The stride of 1 would be 7
     * The stride of 2 would be 1
     *
     * @param type      The type of the array containing the dimensions.
     * @param dimension The dimension index to calculate the stride for.
     * @return The stride of the given dimension.
     */
    private static int calculateStride(TypeNode type, int dimension) {
        int stride = 1;
        // Excluding the first dimension, find the product of the declared sizes of the dimensions.
        for (int i = dimension + 1; i < type.getDepth(); i++)
            stride *= type.getDimensionSize(i).num;
        return stride;
    }

    /**
     * Reduce the array accessors of the loc node to a list of reduced expressions.
     *
     * This will iterate through each ArrayLocNode of the LocNode and reduce its expression and
     * store the resulting reduced expression nodes in a list to be used for calculating the offset.
     *
     * For example, if the LocNoe is a[5][3+10][4*4], it would return a list of expressions
     * [5, t1, t2] where t1 = 3 + 10 and t2 = 4 * 4.
     *
     * @param node The loc node to reduce the array accessors for.
     * @return List of reduced expressions for each dimension.
     */
    private List<ExpressionNode> reduceDimensions(LocNode node) {
        List<ExpressionNode> reducedDimensions = new ArrayList<>();
        // Traverse through each dimension and reduce the expression, and reduce the expression.
        for (ArrayLocNode a = node.array; a != null; a = a.array)
            reducedDimensions.add(reduceExpression(a.expression, true));
        return reducedDimensions;
    }

    /**
     * Add an assignment statement to the current statements list.
     *
     * The left and right should already be properly reduced to at most three values combined. Then
     * a new assignment node is created with them, and it's added to the current list of assignments
     * for the program.
     *
     * @param left  The left side of the assignment.
     * @param right The right side of the assignment.
     */
    public void emitAssignment(LocNode left, ExpressionNode right) {
        AssignmentNode assign = new AssignmentNode();
        assign.left = left;
        assign.expression = right;
        currentStatements.add(assign);
    }

    /**
     * Add a label statement to the current statements list.
     *
     * Example: L1
     *
     * @param label The label to emit.
     */
    public void emitLabel(LabelNode label) {
        currentStatements.add(label);
    }

    /**
     * Add a goto statement to the current statements list.
     *
     * A GoToNode will be created with the given label.
     *
     * Example: goto L1
     *
     * @param label The label to goto.
     */
    public void emitGoto(LabelNode label) {
        currentStatements.add(new GotoNode(label));
    }

    /**
     * Add an ifFalse statement and a goto statement to the current statements list.
     *
     * This will create an ifFalse statement with a condition that will go to the given label
     * if evaluated as false.
     *
     * Example: iffalse t1 goto L1
     *
     * @param expression The expression node to be checked if false.
     * @param label      The label to go to if the expression is false.
     */
    public void emitIfFalse(ExpressionNode expression, LabelNode label) {
        emitLabel(LabelNode.newLabel());
        currentStatements.add(new IfFalseNode(expression));
        currentStatements.add(new GotoNode(label));
    }

    /**
     * Add an ifTrue statement and a goto statement to the current statements list.
     *
     * This is just a basic true statement condition that will go to the given label if evaluated as true.
     * It just uses IfTrueNode because IfNode is already used for the parsed AST if statement.
     *
     * @param expression The expression node to be checked if true.
     * @param label      The label to go to if the expression is true.
     */
    public void emitIfTrue(ExpressionNode expression, LabelNode label) {
        currentStatements.add(new IfTrueNode(expression));
        currentStatements.add(new GotoNode(label));
    }
}
